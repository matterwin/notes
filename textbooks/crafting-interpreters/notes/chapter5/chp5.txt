# 5 Representing code

# 5.1 Context-Free Grammars

formal grammars;
- a set of atomic pieces pieces that forms its "alphabet"



# 5.1.1 Rules for grammars

derivations:
- "strings" generated by starting with the rules to generate its body


productions:
- rules that produce strings in the grammar 

each production in a CFG (context-free grammar) has a head -- its name -- and a body -- describes what it generates.

its body is a list of symbols: terminal and nonterminal


terminal:
- a letter from the grammar's alphabet 
- a literal value
- acts as an "endpoint" b/c they don't lead to more rules to follow
- simply produces that one symbol 
- individual lexemes like "if" or 1234


nonterminal:
- a named reference to another rule in the grammar

Research more on Backus-Naur form (BNF)

regular language can repeat but can't count, therefore context-free language is used here since in this point in the textbook (breakfast grammar example) there is nested recursion where the recursive nonterminal has productions on both sides of it, which means it is not regular

every nonterminal in the string has been expanded until it finally contains only terminals.

any time we hit a rule that had multiple productions, we just picked one arbitarirly.



# 5.1.2 Enhancing our notation

Instead of repeating the rule name each time we want to add another
production for it, we’ll allow a series of productions separated by a pipe (|):

bread → "toast" | "biscuits" | "English muffin" ;


Further, we’ll allow parentheses for grouping and then allow | within that
to select one from a series of options within the middle of a production:

protein → ( "scrambled" | "poached" | "fried" ) "eggs" ;


Using recursion to support repeated sequences of symbols has a certain
appealing purity, but it’s kind of a chore to make a separate named sub-rule
each time we want to loop. So, we also use a postfix * to allow the previous
symbol or group to be repeated zero or more times.

crispiness → "really" "really"* ;


A postfix + is similar, but requires the preceding production to appear at
least once.

crispiness → "really"+ ;


A postfix ? is for an optional production. The thing before it can appear
zero or one time, but not more.

breakfast → protein ( "with" breakfast "on the side" )? ;


Breakfast grammar is now condensed to:

breakfast → protein ( "with" breakfast "on the side" )?
          | bread ;

protein → "really"+ "crispy" "bacon"
          | "sausage"
          | ( "scrambled" | "poached" | "fried" ) "eggs" ;

bread → "toast" | "biscuits" | "English muffin" ;


EBNF is another term to study.
Remember this is context-free above at least.



# 5.1.3 A Grammar for Lox expressions

Will be doing a small subset of Lox to start off with:

Literals – Numbers, strings, Booleans, and nil.

Unary expressions – A prefix ! to perform a logical not, and - to negate a
number.

Binary expressions – The infix arithmetic (+, -, *, /) and logic (==, !=,

Parentheses – A pair of ( and ) wrapped around an expression


Lox grammar:

expression → literal
 | unary
 | binary
 | grouping ;

literal → NUMBER | STRING | "true" | "false" | "nil" ;

grouping → "(" expression ")" ;

unary → ( "-" | "!" ) expression ;

binary → expression operator expression ;

operator → "==" | "!=" | "<" | "<=" | ">" | ">="
 | "+" | "-" | "*" | "/" ;


In addition to quoted strings for terminals that match exact lexemes, we CAPITALIZE terminals that are a single lexeme whose text representation may vary.

NUMBER
- is any number literal

STRING 
- is any string literal 

IDENTIFIER 
- we'll do the same later

this grammar is actually ambiguous, which we'll see when we parse it.
But it is good enough for now.

So, we are defining an abstract-syntax tree (AST).
In a parse tree every single grammar production becomes a node in the tree.

An AST elides productions that aren't needed by later phases.



# 5.2 Implementing Syntax Trees

syntax tree 
- the tree of terminals and nonterminals 


our scanner used a single Token class to rep all kinds of lexemes.

Our syntax trees are not so homogenous.
Unary expr have singler operand 
binary expr have two 
literals have none.

We'll define a base class for expressions -- each production under expression -- and create subclasses that has fields for nonterminals specific to that rule 



# 5.2.2 Metaprogramming the trees 

GenerateAst is a cmd-line script that generates a file named Expr.java



# 5.3.2 The Visitor Pattern

easy example of Visitor pattern:

 abstract class Pastry {}

 class Beignet extends Pastry {}

 class Cruller extends Pastry {}

 --------------------------------

interface PastryVisitor {
  void visitBeignet(Beignet beignet);
  void visitCruller(Cruller cruller);
}

abstract class Pastry {
  abstract void accept(PastryVisitor visitor);
}


Each subclass implements it:

class Beignet extends Pastry {
  @Override
  void accept(PastryVisitor visitor) {
    visitor.visitBeignet(this);
  }
}

class Cruller extends Pastry {
  @Override
  void accept(PastryVisitor visitor) {
    visitor.visitCruller(this);
  }
}


We added one accept() method to each class, and we can use it for as many
visitors as we want without ever having to touch the pastry classes again. It’s a
clever pattern.


















